package main

import (
	"fmt"
	"sync"
	"time"
)

/*
16.5 Не используя context и буферизованные каналы необходимо написать программу,
которая будет запускать 10 рабочих горутин и одну управляющую горутину.
Каждая рабочая горутина с задержкой в 1 секунду должна выводить в stdout
сообщение «сложныевычислениягорутины: 1»,
где 1 - порядковыйномергорутины.
Управляющаягорутина через 3 секунды после своего запуска должна вывести
«ой, всё!», после чего рабочие горутины должны в stdout вывести «stop горутина: 1»,
где 1 - порядковыйномергорутины, изавершитьсвоёвыполнение.
В консоли должны увидеться что-то подобное:
сложныевычислениягорутины:  3
сложныевычислениягорутины:  8
сложныевычислениягорутины:  4
сложныевычислениягорутины:  9
сложныевычислениягорутины:  7
сложныевычислениягорутины:  2
сложныевычислениягорутины:  0
сложныевычислениягорутины:  1
сложныевычислениягорутины:  5
ой, всё!
сложныевычислениягорутины:  6
stop горутина:  3
сложныевычислениягорутины:  3
stop горутина:  9
сложныевычислениягорутины:  9
stop горутина:  7
сложныевычислениягорутины:  4
stop горутина:  4
сложныевычислениягорутины:  8
stop горутина:  8
сложныевычислениягорутины:  6
stop горутина:  6
сложныевычислениягорутины:  2
stop горутина:  2
сложныевычислениягорутины:  0
stop горутина:  0
сложныевычислениягорутины:  1
stop горутина:  1
сложныевычислениягорутины:  5
stop горутина:  5
*/

func main() {
	var wg sync.WaitGroup
	stopChan := make(chan struct{})

	// Запуск 10 рабочих горутин
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			ticker := time.NewTicker(1 * time.Second)
			defer ticker.Stop()
			for {
				select {
				case <-stopChan:
					fmt.Printf("stop горутина: %d\n", i)
					return
				case <-ticker.C:
					fmt.Printf("сложныевычислениягорутины: %d\n", i)
				}
			}
		}(i)
	}

	// Запуск управляющей горутины
	go func() {
		time.Sleep(3 * time.Second)
		fmt.Println("ой, всё!")
		close(stopChan)
	}()

	// Ожидание завершения всех горутин
	wg.Wait()
}
